# This file is part of the Stratosphere Linux IPS
# See the file 'LICENSE' for copying permission.

from colors import *
import cPickle
import math

class Model():
    def __init__(self, id):
        self.id = id
        self.init_vector = False
        self.matrix = False
        self.self_probability = -1
        self.label = -1

    def compute_probability(self, state):
        """ Given a chain of letters, return the probability that it was generated by this MC """
        i = 0
        probability = 0
        ignored = 0
        # Get the initial probability of this letter in the IV.
        try:
            init_letter_prob = math.log(self.init_vector[state[i]])
        except ValueError:
            # There is not enough data to even create a matrix
            init_letter_prob = 0           
        except IndexError:
            # The first letter is not in the matrix, so penalty...
            init_letter_prob = -4.6        
        # We should have more than 2 states at least
        while i < len(state) and len(state) > 1: 
            try:
                vector = state[i] + state[i+1] 
                growing_v = state[0:i+2]       
                # The transitions that include the # char will be automatically excluded
                temp_prob = self.matrix.walk_probability(vector)
                i += 1
                if temp_prob != float('-inf'):                 
                    probability = probability + temp_prob # logs should be summed up
                    #print_info('\tTransition [{}:{}]: {} -> Prob:{:.10f}. CumProb: {}'.format(i-1, i,vector, temp_prob, probability))
                else:
                    # Here is our trick. If two letters are not in the matrix... assign a penalty probability
                    # The temp_prob is the penalty we assign if we can't find the transition
                    temp_prob = -4.6 # Which is approx 0.01 probability
                    probability = probability + temp_prob # logs should be + 
                    if '#' not in vector:          
                        ignored += 1                   
                    continue
            except IndexError:             
                # We are out of letters        
                break
        #if ignored:
            #print_warning('Ignored transitions: {}'.format(ignored))
            #ignored = 0
        return probability             


    def set_state(self, state):
        self.state = state

    def get_state(self):
        return self.state

    def get_id(self):
        return self.id

    def set_init_vector(self, vector):
        self.init_vector = vector

    def get_init_vector(self):
        return self.init_vector

    def set_matrix(self, matrix):
        self.matrix = matrix

    def get_matrix(self):
        return self.matrix

    def set_self_probability(self, prob):
        self.self_probability = prob

    def get_self_probability(self):
        return self.self_probability

    def set_label(self, label):
        self.label = label
        protocol = label.split('-')[2]
        self.set_protocol(protocol)
        # Set the responce that should be given if matched
        if 'normal' in label.lower():
            self.matched = False
        else:
            self.matched = True

    def get_label(self):
        return self.label

    def set_protocol(self, protocol):
        self.protocol = protocol

    def get_protocol(self):
        return self.protocol

    def set_threshold(self, threshold):
        self.threshold = threshold

    def get_threshold(self):
        return self.threshold


class MarkovModelsDetection():
    """ 
    Class that do all the detection using markov models
    """
    def __init__(self):
        self.models = []

    def is_periodic(self,state):
        basic_patterns = ['a,a,a,','b,b,b,', 'c,c,c,', 'd,d,d,', 'e,e,e,', 'f,f,f,', 'g,g,g,', 'h,h,h,', 'i,i,i,', 'a+a+a+', 'b+b+b+', 'c+c+c+', 'd+d+d+', 'e+e+e+', 'f+f+f+', 'g+g+g+', 'h+h+h+', 'i+i+i+', 'a*a*a*', 'b*b*b*', 'c*c*c*', 'd*d*d*', 'e*e*e*', 'f*f*f*', 'g*g*g*', 'h*h*h*', 'i*i*i*', 'A,A,A,','B,B,B,', 'C,C,C,', 'D,D,D,', 'E,E,E,', 'F,F,F,', 'G,G,G,', 'H,H,H,', 'I,I,I,', 'A+A+A+', 'B+B+B+', 'C+C+C+', 'D+D+D+', 'E+E+E+', 'F+F+F+', 'G+G+G+', 'H+H+H+', 'I+I+I+', 'A*A*A*', 'B*B*B*', 'C*C*C*', 'D*D*D*', 'E*E*E*', 'F*F*F*', 'G*G*G*', 'H*H*H*', 'I*I*I*']
        for pattern in basic_patterns:
            if pattern in state:
                return True

    def set_model_to_detect(self, file):
        """ 
        Receives a file and extracts the model in it
        """
        input = open(file, 'r') 
        try: 
            id = self.models[-1].get_id() + 1
        except (KeyError, IndexError):
            id = 1
        model = Model(id)
        model.set_init_vector(cPickle.load(input))
        model.set_matrix(cPickle.load(input))
        model.set_state(cPickle.load(input))
        model.set_self_probability(cPickle.load(input))
        model.set_label(cPickle.load(input))
        model.set_threshold(cPickle.load(input))
        self.models.append(model)
        print 'Adding model {} to the list.'.format(model.get_label())
        input.close() 

    def detect(self, tuple, verbose):
        """
        Main detect function
        """
        self.verbose = verbose
        # Only detect states with more than 3 letters
        #if len(tuple.get_state()) < 4:
        if len(tuple.get_state()[tuple.get_max_state_len():]) < 4:
            return (False, False)
        # Use the current models for detection
        for model in self.models:
            # Only detect if protocol matches
            if model.get_protocol().lower() != tuple.get_protocol().lower():
                return (False, False)
            # Letters of the trained model. Get from the last detected letter to the end. NO CUT HERE. We dont cut the training letters, because if we do, we have to cut ALL of them, 
            # including the matching and the not matching ones.
            train_sequence = model.get_state()[0:len(tuple.get_state())]
            # We dont recreate the matrix because the trained is never cutted. # First re-create the matrix only for this sequence 
            ##model.create(train_sequence)
            # Get the new original prob so far...
            training_original_prob = model.compute_probability(train_sequence)
            # Now obtain the probability for testing. The prob is computed by using the API on the train model, which knows its own matrix
            test_prob = model.compute_probability(tuple.get_state()[tuple.get_max_state_len():])
            # Get the distance             
            prob_distance = -1             
            if training_original_prob != -1 and test_prob != -1 and training_original_prob <= test_prob:
                try:                       
                    prob_distance = training_original_prob / test_prob
                except ZeroDivisionError:          
                    prob_distance = -1         
            elif training_original_prob != -1 and test_prob != -1 and training_original_prob > test_prob:
                try:                       
                    prob_distance = test_prob / training_original_prob
                except ZeroDivisionError:          
                    prob_distance = -1 
            if self.verbose > 2:
                #print tuple.get_min_state_len()
                #print tuple.get_max_state_len()
                print 'Trained Model: {}. Label: {}. State: {}'.format(model.get_id(), model.get_label(), train_sequence)
                #print 'Test Model: {}. State: {}'.format(tuple.get_id(), tuple.get_state()) 
                print 'Test Model: {}. State: {}'.format(tuple.get_id(), tuple.get_state()[tuple.get_max_state_len():])
                print 'Train prob: {}'.format(training_original_prob)
                print 'Test prob: {}'.format(test_prob)
                print 'Distance: {}'.format(prob_distance)
            # Now just return the first model that matches
            if prob_distance <= model.get_threshold():
                if tuple.get_max_state_len() == 0:
                    # first time matched. move only the max
                    tuple.set_max_state_len(len(tuple.get_state()))
                else:
                    tuple.set_min_state_len(tuple.get_max_state_len())
                    tuple.set_max_state_len(len(tuple.get_state()))
                return (model.matched, model.get_label())
        return (False, False)


__markov_models__ = MarkovModelsDetection()
